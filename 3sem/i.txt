pipe:
find . -type f grep .c /*заканчиваются на .c*/ grep -v freertos /* не содержит в имени файла freertos */


создание pipe: 

int pipe(int fd[2]);
fd[0] - используется для записи rd only
fd[1] - используется для чтения wr only
После создания pipe fork (для унаследоваиния fd) счетчик использования равен 4
до fork 2 - два дескриптора
если другой конец закрыт, то при read немедленно возвращается 0
если пишем в pipe, у которого конец закрыт - ошибка, процесс убивается

процесс, который породит дочерний процесс, который читает файл, родительский процесс получает данные из дочернего процесса и выводит на экран

fifo:
mkfifo("name", 0666) // создается один раз

1)пользователь
2)группа
3)все

fd = open("fifo", O_RDONLY)
O_RDONLY O_NONBLOCK - даже если нет второго конца все ок
O_WRONLY O_NONBLOCK - нет второго конца, блок
O_RDONlY и O_WRONLY - создается пайп

1 задача:
__________
Написать одну прогу, работающую в 2 режимах, в зависимости от параметра командной строки
(2 программы)
1 - должна открыть файл и передать его в другую программу
2 - должна получить этот файл и вывести его на экран
Данные преедаются через FIFO, программы запускаются в разных терминалах, они не связаны отношением родитель - ребенок
Передавать файл посимвольно нельзя - очень медленно
С файлами оперируют поблочно, брать размер блока 16 Кб
Размер файла нелимитирован
Вводная: когда мы открываем fifo
можно открыть два процесса на чтение фифо
аналогично можно открыть два процесса на вывод
Поэтому нужно сделать так, чтобы выходной файл не портился
(Любым способом) После чтения из пайпа данные исчезают из пайпа
fcntl нельзя файловые локи
(произвольное количество чтений на пайпе)
Можно пользоваться любым количеством файлов, любым количеством фифо

